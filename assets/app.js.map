{"version":3,"file":"app.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3EA;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACHA;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://webpack-build-process/./assets-src/scss/app.scss","webpack://webpack-build-process/../swup/node_modules/delegate-it/index.js","webpack://webpack-build-process/../swup/src/helpers.js","webpack://webpack-build-process/../swup/src/helpers/Link.js","webpack://webpack-build-process/../swup/src/helpers/classify.js","webpack://webpack-build-process/../swup/src/helpers/cleanupAnimationClasses.js","webpack://webpack-build-process/../swup/src/helpers/createHistoryRecord.js","webpack://webpack-build-process/../swup/src/helpers/fetch.js","webpack://webpack-build-process/../swup/src/helpers/getCurrentUrl.js","webpack://webpack-build-process/../swup/src/helpers/getDataFromHtml.js","webpack://webpack-build-process/../swup/src/helpers/index.js","webpack://webpack-build-process/../swup/src/helpers/markSwupElements.js","webpack://webpack-build-process/../swup/src/helpers/normalizeUrl.js","webpack://webpack-build-process/../swup/src/helpers/updateHistoryRecord.js","webpack://webpack-build-process/../swup/src/index.js","webpack://webpack-build-process/../swup/src/modules/Cache.js","webpack://webpack-build-process/../swup/src/modules/enterPage.js","webpack://webpack-build-process/../swup/src/modules/getAnchorElement.js","webpack://webpack-build-process/../swup/src/modules/getAnimationPromises.js","webpack://webpack-build-process/../swup/src/modules/getPageData.js","webpack://webpack-build-process/../swup/src/modules/leavePage.js","webpack://webpack-build-process/../swup/src/modules/loadPage.js","webpack://webpack-build-process/../swup/src/modules/off.js","webpack://webpack-build-process/../swup/src/modules/on.js","webpack://webpack-build-process/../swup/src/modules/plugins.js","webpack://webpack-build-process/../swup/src/modules/renderPage.js","webpack://webpack-build-process/../swup/src/modules/triggerEvent.js","webpack://webpack-build-process/../swup/src/modules/updateTransition.js","webpack://webpack-build-process/../swup/src/utils.js","webpack://webpack-build-process/../swup/src/utils/index.js","webpack://webpack-build-process/webpack/bootstrap","webpack://webpack-build-process/webpack/runtime/define property getters","webpack://webpack-build-process/webpack/runtime/hasOwnProperty shorthand","webpack://webpack-build-process/webpack/runtime/make namespace object","webpack://webpack-build-process/./assets-src/js/app.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","const ledger = /* @__PURE__ */ new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n  var _a, _b;\n  if (!wanted && !ledger.has(baseElement)) {\n    return false;\n  }\n  const elementMap = (_a = ledger.get(baseElement)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new WeakMap();\n  ledger.set(baseElement, elementMap);\n  if (!wanted && !ledger.has(baseElement)) {\n    return false;\n  }\n  const setups = (_b = elementMap.get(callback)) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Set();\n  elementMap.set(callback, setups);\n  const existed = setups.has(setup);\n  if (wanted) {\n    setups.add(setup);\n  } else {\n    setups.delete(setup);\n  }\n  return existed && wanted;\n}\nfunction isEventTarget(elements) {\n  return typeof elements.addEventListener === \"function\";\n}\nfunction safeClosest(event, selector) {\n  let target = event.target;\n  if (target instanceof Text) {\n    target = target.parentElement;\n  }\n  if (target instanceof Element && event.currentTarget instanceof Element) {\n    const closest = target.closest(selector);\n    if (closest && event.currentTarget.contains(closest)) {\n      return closest;\n    }\n  }\n}\nfunction delegate(base, selector, type, callback, options) {\n  if (typeof base === \"string\") {\n    base = document.querySelectorAll(base);\n  }\n  if (!isEventTarget(base)) {\n    const subscriptions = Array.prototype.map.call(base, (element) => delegate(element, selector, type, callback, options));\n    return {\n      destroy() {\n        for (const subscription of subscriptions) {\n          subscription.destroy();\n        }\n      }\n    };\n  }\n  const baseElement = base instanceof Document ? base.documentElement : base;\n  const capture = Boolean(typeof options === \"object\" ? options.capture : options);\n  const listenerFn = (event) => {\n    const delegateTarget = safeClosest(event, selector);\n    if (delegateTarget) {\n      event.delegateTarget = delegateTarget;\n      callback.call(baseElement, event);\n    }\n  };\n  if (typeof options === \"object\") {\n    delete options.once;\n  }\n  const setup = JSON.stringify({ selector, type, capture });\n  const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n  const delegateSubscription = {\n    destroy() {\n      baseElement.removeEventListener(type, listenerFn, options);\n      editLedger(false, baseElement, callback, setup);\n    }\n  };\n  if (!isAlreadyListening) {\n    baseElement.addEventListener(type, listenerFn, options);\n  }\n  return delegateSubscription;\n}\nexport default delegate;\n","export * from \"./helpers/index.js\";\n","export default class Link {\n  constructor(elementOrUrl) {\n    if (elementOrUrl instanceof Element || elementOrUrl instanceof SVGElement) {\n      this.link = elementOrUrl;\n    } else {\n      this.link = document.createElement(\"a\");\n      this.link.href = elementOrUrl;\n    }\n  }\n  getPath() {\n    let path = this.link.pathname;\n    if (path[0] !== \"/\") {\n      path = \"/\" + path;\n    }\n    return path;\n  }\n  getAddress() {\n    let path = this.link.pathname + this.link.search;\n    if (this.link.getAttribute(\"xlink:href\")) {\n      path = this.link.getAttribute(\"xlink:href\");\n    }\n    if (path[0] !== \"/\") {\n      path = \"/\" + path;\n    }\n    return path;\n  }\n  getHash() {\n    return this.link.hash;\n  }\n}\n","const classify = (text) => {\n  let output = text.toString().toLowerCase().replace(/\\s+/g, \"-\").replace(/\\//g, \"-\").replace(/[^\\w\\-]+/g, \"\").replace(/\\-\\-+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n  if (output[0] === \"/\")\n    output = output.splice(1);\n  if (output === \"\")\n    output = \"homepage\";\n  return output;\n};\nexport default classify;\n","const cleanupAnimationClasses = () => {\n  document.documentElement.className.split(\" \").forEach((classItem) => {\n    if (new RegExp(\"^to-\").test(classItem) || classItem === \"is-changing\" || classItem === \"is-rendering\" || classItem === \"is-popstate\" || classItem === \"is-fragment\") {\n      document.documentElement.classList.remove(classItem);\n    }\n  });\n};\nexport default cleanupAnimationClasses;\n","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst createHistoryRecord = (url, customData = {}) => {\n  url = url || window.location.href.split(window.location.hostname)[1];\n  const data = __spreadValues({\n    url,\n    random: Math.random(),\n    source: \"swup\"\n  }, customData);\n  window.history.pushState(data, document.title, url);\n};\nexport default createHistoryRecord;\n","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst fetch = (setOptions, callback = false) => {\n  let defaults = {\n    url: window.location.pathname + window.location.search,\n    method: \"GET\",\n    data: null,\n    headers: {}\n  };\n  let options = __spreadValues(__spreadValues({}, defaults), setOptions);\n  let request = new XMLHttpRequest();\n  request.onreadystatechange = function() {\n    if (request.readyState === 4) {\n      if (request.status !== 500) {\n        callback(request);\n      } else {\n        callback(request);\n      }\n    }\n  };\n  request.open(options.method, options.url, true);\n  Object.keys(options.headers).forEach((key) => {\n    request.setRequestHeader(key, options.headers[key]);\n  });\n  request.send(options.data);\n  return request;\n};\nexport default fetch;\n","const getCurrentUrl = () => {\n  return window.location.pathname + window.location.search;\n};\nexport default getCurrentUrl;\n","import { query, queryAll } from \"../utils.js\";\nconst getDataFromHtml = (html, options) => {\n  let fakeDom = document.createElement(\"html\");\n  fakeDom.innerHTML = html;\n  let blocks = [];\n  let fragments = {};\n  if (Array.isArray(options)) {\n    options = { containers: options };\n  }\n  const { containers = [], fragmentContainerAttr } = options || {};\n  containers.forEach((selector) => {\n    if (query(selector, fakeDom) == null) {\n      console.warn(`[swup] Container ${selector} not found on page.`);\n      return null;\n    } else {\n      if (queryAll(selector).length !== queryAll(selector, fakeDom).length) {\n        console.warn(`[swup] Mismatched number of containers found on new page.`);\n      }\n      queryAll(selector).forEach((item, index) => {\n        queryAll(selector, fakeDom)[index].setAttribute(\"data-swup\", blocks.length);\n        blocks.push(queryAll(selector, fakeDom)[index].outerHTML);\n      });\n    }\n  });\n  queryAll(`[${fragmentContainerAttr}]`, fakeDom).forEach((container) => {\n    const name = container.getAttribute(fragmentContainerAttr);\n    if (!name) {\n      console.warn(\"[swup] Fragment container is missing required name\");\n    } else if (fragments[name]) {\n      console.warn(`[swup] Duplicate fragment container found with name #${name}`);\n    } else {\n      fragments[name] = container.outerHTML;\n    }\n  });\n  const title = (fakeDom.querySelector(\"title\") || {}).innerText;\n  const pageClass = fakeDom.querySelector(\"body\").className;\n  fakeDom.innerHTML = \"\";\n  fakeDom = null;\n  return { title, pageClass, blocks, fragments, originalContent: html };\n};\nexport default getDataFromHtml;\n","export { default as classify } from \"./classify.js\";\nexport { default as createHistoryRecord } from \"./createHistoryRecord.js\";\nexport { default as updateHistoryRecord } from \"./updateHistoryRecord.js\";\nexport { default as getDataFromHtml } from \"./getDataFromHtml.js\";\nexport { default as fetch } from \"./fetch.js\";\nexport { default as getCurrentUrl } from \"./getCurrentUrl.js\";\nexport { default as normalizeUrl } from \"./normalizeUrl.js\";\nexport { default as markSwupElements } from \"./markSwupElements.js\";\nexport { default as Link } from \"./Link.js\";\nexport { default as cleanupAnimationClasses } from \"./cleanupAnimationClasses.js\";\n","import { query, queryAll } from \"../utils.js\";\nconst markSwupElements = (element, containers) => {\n  let blocks = 0;\n  containers.forEach((selector) => {\n    if (query(selector, element) == null) {\n      console.warn(`[swup] Container ${selector} not found on page.`);\n    } else {\n      queryAll(selector).forEach((item, index) => {\n        queryAll(selector, element)[index].setAttribute(\"data-swup\", blocks);\n        blocks++;\n      });\n    }\n  });\n};\nexport default markSwupElements;\n","import Link from \"./Link.js\";\nconst normalizeUrl = (url) => {\n  return new Link(url).getAddress();\n};\nexport default normalizeUrl;\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst updateHistoryRecord = (url = null, customData = {}) => {\n  url = url || window.location.href;\n  const data = __spreadValues(__spreadProps(__spreadValues({}, window.history.state), {\n    url,\n    random: Math.random(),\n    source: \"swup\"\n  }), customData);\n  window.history.replaceState(data, document.title, url);\n};\nexport default updateHistoryRecord;\n","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nimport delegate from \"delegate-it\";\nimport Cache from \"./modules/Cache.js\";\nimport loadPage from \"./modules/loadPage.js\";\nimport leavePage from \"./modules/leavePage.js\";\nimport renderPage from \"./modules/renderPage.js\";\nimport enterPage from \"./modules/enterPage.js\";\nimport triggerEvent from \"./modules/triggerEvent.js\";\nimport on from \"./modules/on.js\";\nimport off from \"./modules/off.js\";\nimport updateTransition from \"./modules/updateTransition.js\";\nimport getAnchorElement from \"./modules/getAnchorElement.js\";\nimport getAnimationPromises from \"./modules/getAnimationPromises.js\";\nimport getPageData from \"./modules/getPageData.js\";\nimport { use, unuse, findPlugin } from \"./modules/plugins.js\";\nimport { queryAll } from \"./utils.js\";\nimport {\n  getCurrentUrl,\n  markSwupElements,\n  Link,\n  cleanupAnimationClasses,\n  updateHistoryRecord\n} from \"./helpers.js\";\nexport default class Swup {\n  constructor(setOptions) {\n    let defaults = {\n      animateHistoryBrowsing: false,\n      animationSelector: '[class*=\"transition-\"]',\n      linkSelector: `a[href^=\"${window.location.origin}\"]:not([data-no-swup]), a[href^=\"/\"]:not([data-no-swup]), a[href^=\"#\"]:not([data-no-swup])`,\n      cache: true,\n      containers: [\"#swup\"],\n      requestHeaders: {\n        \"X-Requested-With\": \"swup\",\n        Accept: \"text/html, application/xhtml+xml\"\n      },\n      plugins: [],\n      skipPopStateHandling: function(event) {\n        return !(event.state && event.state.source === \"swup\");\n      },\n      fragmentTargetAttr: \"data-swup-to-fragment\",\n      fragmentContainerAttr: \"data-swup-fragment-container\"\n    };\n    const options = __spreadValues(__spreadValues({}, defaults), setOptions);\n    this._handlers = {\n      animationInDone: [],\n      animationInStart: [],\n      animationOutDone: [],\n      animationOutStart: [],\n      animationSkipped: [],\n      clickLink: [],\n      contentReplaced: [],\n      fragmentsReplaced: [],\n      disabled: [],\n      enabled: [],\n      openPageInNewTab: [],\n      pageLoaded: [],\n      pageRetrievedFromCache: [],\n      pageView: [],\n      popState: [],\n      samePage: [],\n      samePageWithHash: [],\n      serverError: [],\n      transitionStart: [],\n      transitionEnd: [],\n      willReplaceContent: [],\n      willReplaceFragments: []\n    };\n    this.scrollToElement = null;\n    this.preloadPromise = null;\n    this.options = options;\n    this.plugins = [];\n    this.transition = {};\n    this.delegatedListeners = {};\n    this.boundPopStateHandler = this.popStateHandler.bind(this);\n    this.cache = new Cache();\n    this.cache.swup = this;\n    this.loadPage = loadPage;\n    this.leavePage = leavePage;\n    this.renderPage = renderPage;\n    this.enterPage = enterPage;\n    this.triggerEvent = triggerEvent;\n    this.on = on;\n    this.off = off;\n    this.updateTransition = updateTransition;\n    this.getAnimationPromises = getAnimationPromises;\n    this.getPageData = getPageData;\n    this.getAnchorElement = getAnchorElement;\n    this.log = () => {\n    };\n    this.use = use;\n    this.unuse = unuse;\n    this.findPlugin = findPlugin;\n    this.getCurrentUrl = getCurrentUrl;\n    this.cleanupAnimationClasses = cleanupAnimationClasses;\n    this.currentURL = getCurrentUrl();\n    this.enable();\n  }\n  enable() {\n    if (typeof Promise === \"undefined\") {\n      console.warn(\"Promise is not supported\");\n      return;\n    }\n    this.delegatedListeners.click = delegate(\n      document,\n      this.options.linkSelector,\n      \"click\",\n      this.linkClickHandler.bind(this)\n    );\n    window.addEventListener(\"popstate\", this.boundPopStateHandler);\n    if (this.options.cache) {\n    }\n    markSwupElements(document.documentElement, this.options.containers);\n    this.options.plugins.forEach((plugin) => {\n      this.use(plugin);\n    });\n    updateHistoryRecord();\n    this.triggerEvent(\"enabled\");\n    document.documentElement.classList.add(\"swup-enabled\");\n    this.triggerEvent(\"pageView\");\n  }\n  destroy() {\n    this.delegatedListeners.click.destroy();\n    window.removeEventListener(\"popstate\", this.boundPopStateHandler);\n    this.cache.empty();\n    this.options.plugins.forEach((plugin) => {\n      this.unuse(plugin);\n    });\n    queryAll(\"[data-swup]\").forEach((element) => {\n      element.removeAttribute(\"data-swup\");\n    });\n    this.off();\n    this.triggerEvent(\"disabled\");\n    document.documentElement.classList.remove(\"swup-enabled\");\n  }\n  linkClickHandler(event) {\n    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n      this.triggerEvent(\"openPageInNewTab\", event);\n      return;\n    }\n    if (event.button !== 0) {\n      return;\n    }\n    this.triggerEvent(\"clickLink\", event);\n    event.preventDefault();\n    const link = new Link(event.delegateTarget);\n    const url = link.getAddress();\n    const hash = link.getHash();\n    if (url == getCurrentUrl() || url == \"\") {\n      if (!hash) {\n        this.triggerEvent(\"samePage\", event);\n      } else {\n        this.triggerEvent(\"samePageWithHash\", event);\n        const element = getAnchorElement(hash);\n        if (element) {\n          updateHistoryRecord(url + hash);\n        } else {\n          console.warn(`Element for offset not found (#${hash})`);\n        }\n      }\n    } else {\n      this.scrollToElement = hash || null;\n      const customTransition = event.delegateTarget.getAttribute(\"data-swup-transition\");\n      let fragment = false;\n      const { fragmentTargetAttr: attr } = this.options;\n      const targetEl = event.delegateTarget.closest(`[${attr}]`);\n      if (targetEl && targetEl.matches(`[${attr}]:not([${attr}=\"_top\"])`)) {\n        fragment = targetEl.getAttribute(attr) || true;\n      }\n      this.loadPage({ url, fragment, customTransition }, false);\n    }\n  }\n  popStateHandler(event) {\n    if (this.options.skipPopStateHandling(event)) {\n      return;\n    }\n    const { url = window.location.href, fragment } = event.state || {};\n    const link = new Link(url);\n    if (link.getHash()) {\n      this.scrollToElement = link.getHash();\n    } else {\n      event.preventDefault();\n    }\n    this.triggerEvent(\"popState\", event);\n    if (!this.options.animateHistoryBrowsing) {\n      document.documentElement.classList.remove(\"is-animating\");\n      cleanupAnimationClasses();\n    }\n    this.loadPage({ url: link.getAddress(), fragment }, event);\n  }\n}\n","import { getCurrentUrl, normalizeUrl } from \"../helpers.js\";\nexport class Cache {\n  constructor() {\n    this.pages = {};\n    this.last = null;\n  }\n  cacheUrl(page) {\n    page.url = normalizeUrl(page.url);\n    if (page.url in this.pages === false) {\n      this.pages[page.url] = page;\n    }\n    this.last = this.pages[page.url];\n    this.swup.log(`Cache (${Object.keys(this.pages).length})`, this.pages);\n  }\n  getPage(url) {\n    url = normalizeUrl(url);\n    return this.pages[url];\n  }\n  getCurrentPage() {\n    return this.getPage(getCurrentUrl());\n  }\n  exists(url) {\n    url = normalizeUrl(url);\n    return url in this.pages;\n  }\n  empty() {\n    this.pages = {};\n    this.last = null;\n    this.swup.log(\"Cache cleared\");\n  }\n  remove(url) {\n    delete this.pages[url];\n  }\n}\nexport default Cache;\n","import { nextTick } from \"../utils.js\";\nconst enterPage = function({ popstate = false, skipTransition = false } = {}) {\n  if (skipTransition) {\n    this.triggerEvent(\"transitionEnd\", popstate);\n    this.cleanupAnimationClasses();\n    return [Promise.resolve()];\n  }\n  nextTick(() => {\n    this.triggerEvent(\"animationInStart\");\n    document.documentElement.classList.remove(\"is-animating\");\n  });\n  const animationPromises = this.getAnimationPromises(\"in\");\n  Promise.all(animationPromises).then(() => {\n    this.triggerEvent(\"animationInDone\");\n    this.triggerEvent(\"transitionEnd\", popstate);\n    this.cleanupAnimationClasses();\n  });\n  return animationPromises;\n};\nexport default enterPage;\n","import { escapeCssIdentifier, query } from \"../utils.js\";\nconst getAnchorElement = (hash) => {\n  if (!hash) {\n    return null;\n  }\n  if (hash.charAt(0) === \"#\") {\n    hash = hash.substring(1);\n  }\n  hash = decodeURIComponent(hash);\n  hash = escapeCssIdentifier(hash);\n  return query(`#${hash}`) || query(`a[name='${hash}']`);\n};\nexport default getAnchorElement;\n","import { queryAll, toMs } from \"../utils.js\";\nlet transitionProp = \"transition\";\nlet transitionEndEvent = \"transitionend\";\nlet animationProp = \"animation\";\nlet animationEndEvent = \"animationend\";\nif (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {\n  transitionProp = \"WebkitTransition\";\n  transitionEndEvent = \"webkitTransitionEnd\";\n}\nif (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {\n  animationProp = \"WebkitAnimation\";\n  animationEndEvent = \"webkitAnimationEnd\";\n}\nexport default function getAnimationPromises() {\n  const selector = this.options.animationSelector;\n  const animatedElements = queryAll(selector, document.body);\n  if (!animatedElements.length) {\n    console.warn(`[swup] No animated elements found by selector ${selector}`);\n    return [Promise.resolve()];\n  }\n  return animatedElements.map((element) => getAnimationPromiseForElement(element, selector));\n}\nfunction getAnimationPromiseForElement(element, selector, expectedType = null) {\n  const { type, timeout, propCount } = getTransitionInfo(element, expectedType);\n  if (!type || !timeout) {\n    console.warn(\n      `[swup] No CSS transition duration defined for element of selector ${selector}`\n    );\n    return Promise.resolve();\n  }\n  return new Promise((resolve) => {\n    const endEvent = type === \"transition\" ? transitionEndEvent : animationEndEvent;\n    const startTime = performance.now();\n    let propsTransitioned = 0;\n    const end = () => {\n      element.removeEventListener(endEvent, onEnd);\n      resolve();\n    };\n    const onEnd = (event) => {\n      if (event.target !== element) {\n        return;\n      }\n      const elapsedTime = (performance.now() - startTime) / 1e3;\n      if (elapsedTime < event.elapsedTime) {\n        return;\n      }\n      if (++propsTransitioned >= propCount) {\n        end();\n      }\n    };\n    setTimeout(() => {\n      if (propsTransitioned < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    element.addEventListener(endEvent, onEnd);\n  });\n}\nexport function getTransitionInfo(element, expectedType = null) {\n  const styles = window.getComputedStyle(element);\n  const transitionDelays = (styles[`${transitionProp}Delay`] || \"\").split(\", \");\n  const transitionDurations = (styles[`${transitionProp}Duration`] || \"\").split(\", \");\n  const transitionTimeout = calculateTimeout(transitionDelays, transitionDurations);\n  const animationDelays = (styles[`${animationProp}Delay`] || \"\").split(\", \");\n  const animationDurations = (styles[`${animationProp}Duration`] || \"\").split(\", \");\n  const animationTimeout = calculateTimeout(animationDelays, animationDurations);\n  let type = \"\";\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === \"transition\") {\n    if (transitionTimeout > 0) {\n      type = \"transition\";\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === \"animation\") {\n    if (animationTimeout > 0) {\n      type = \"animation\";\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? \"transition\" : \"animation\" : null;\n    propCount = type ? type === \"transition\" ? transitionDurations.length : animationDurations.length : 0;\n  }\n  return {\n    type,\n    timeout,\n    propCount\n  };\n}\nfunction calculateTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((duration, i) => toMs(duration) + toMs(delays[i])));\n}\n","import { getDataFromHtml } from \"../helpers.js\";\nconst getPageData = function(request) {\n  const html = request.responseText;\n  const pageObject = getDataFromHtml(html, this.options);\n  if (!pageObject) {\n    console.warn(\"[swup] Received page is invalid.\");\n    return null;\n  }\n  pageObject.responseURL = request.responseURL || window.location.href;\n  return pageObject;\n};\nexport default getPageData;\n","import { classify } from \"../helpers.js\";\nconst leavePage = function(data, { popstate = false, skipTransition = false } = {}) {\n  if (skipTransition) {\n    this.triggerEvent(\"animationSkipped\");\n    return [Promise.resolve()];\n  }\n  this.triggerEvent(\"animationOutStart\");\n  document.documentElement.classList.add(\"is-changing\");\n  document.documentElement.classList.add(\"is-leaving\");\n  document.documentElement.classList.add(\"is-animating\");\n  if (popstate) {\n    document.documentElement.classList.add(\"is-popstate\");\n  }\n  document.documentElement.classList.add(`to-${classify(data.url)}`);\n  const animationPromises = this.getAnimationPromises(\"out\");\n  Promise.all(animationPromises).then(() => {\n    this.triggerEvent(\"animationOutDone\");\n  });\n  return animationPromises;\n};\nexport default leavePage;\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nimport { classify, createHistoryRecord, updateHistoryRecord, fetch, getCurrentUrl } from \"../helpers.js\";\nconst loadPage = function(data, popstate = false) {\n  let animationPromises = [];\n  let xhrPromise;\n  const { url, fragment, customTransition } = data;\n  const skipTransition = fragment || popstate && !this.options.animateHistoryBrowsing;\n  this.triggerEvent(\"transitionStart\", popstate);\n  this.updateTransition(window.location.pathname, url, customTransition);\n  if (customTransition != null) {\n    document.documentElement.classList.add(`to-${classify(customTransition)}`);\n  }\n  animationPromises = this.leavePage(data, { popstate, skipTransition });\n  if (!popstate) {\n    updateHistoryRecord(this.currentURL, { fragment });\n    createHistoryRecord(url + (this.scrollToElement || \"\"), { fragment });\n  }\n  this.currentURL = getCurrentUrl();\n  if (this.cache.exists(url)) {\n    xhrPromise = Promise.resolve(this.cache.getPage(url));\n    this.triggerEvent(\"pageRetrievedFromCache\");\n  } else if (this.preloadPromise && this.preloadPromise.route === url) {\n    xhrPromise = this.preloadPromise;\n  } else {\n    xhrPromise = new Promise((resolve, reject) => {\n      fetch(__spreadProps(__spreadValues({}, data), { headers: this.options.requestHeaders }), (response) => {\n        if (response.status === 500) {\n          this.triggerEvent(\"serverError\");\n          reject(url);\n          return;\n        }\n        const page = this.getPageData(response);\n        if (!page || !page.blocks.length) {\n          reject(url);\n          return;\n        }\n        page.url = url;\n        this.cache.cacheUrl(page);\n        this.triggerEvent(\"pageLoaded\");\n        resolve(page);\n      });\n    });\n  }\n  Promise.all([xhrPromise].concat(animationPromises)).then(([pageData]) => {\n    this.renderPage(pageData, { popstate, fragment, skipTransition });\n    this.preloadPromise = null;\n  }).catch((errorUrl) => {\n    this.options.skipPopStateHandling = function() {\n      window.location = errorUrl;\n      return true;\n    };\n    window.history.go(-1);\n  });\n};\nexport default loadPage;\n","const off = function off2(event, handler) {\n  if (event != null) {\n    if (handler != null) {\n      if (this._handlers[event] && this._handlers[event].filter((savedHandler) => savedHandler === handler).length) {\n        let toRemove = this._handlers[event].filter(\n          (savedHandler) => savedHandler === handler\n        )[0];\n        let index = this._handlers[event].indexOf(toRemove);\n        if (index > -1) {\n          this._handlers[event].splice(index, 1);\n        }\n      } else {\n        console.warn(`Handler for event '${event}' no found.`);\n      }\n    } else {\n      this._handlers[event] = [];\n    }\n  } else {\n    Object.keys(this._handlers).forEach((keys) => {\n      this._handlers[keys] = [];\n    });\n  }\n};\nexport default off;\n","const on = function on2(event, handler) {\n  if (this._handlers[event]) {\n    this._handlers[event].push(handler);\n  } else {\n    console.warn(`Unsupported event ${event}.`);\n  }\n};\nexport default on;\n","export const use = function(plugin) {\n  if (!plugin.isSwupPlugin) {\n    console.warn(`Not swup plugin instance ${plugin}.`);\n    return;\n  }\n  this.plugins.push(plugin);\n  plugin.swup = this;\n  if (typeof plugin._beforeMount === \"function\") {\n    plugin._beforeMount();\n  }\n  plugin.mount();\n  return this.plugins;\n};\nexport const unuse = function(plugin) {\n  let pluginReference;\n  if (typeof plugin === \"string\") {\n    pluginReference = this.plugins.find((p) => plugin === p.name);\n  } else {\n    pluginReference = plugin;\n  }\n  if (!pluginReference) {\n    console.warn(\"No such plugin.\");\n    return;\n  }\n  pluginReference.unmount();\n  if (typeof pluginReference._afterUnmount === \"function\") {\n    pluginReference._afterUnmount();\n  }\n  const index = this.plugins.indexOf(pluginReference);\n  this.plugins.splice(index, 1);\n  return this.plugins;\n};\nexport const findPlugin = function(pluginName) {\n  return this.plugins.find((p) => pluginName === p.name);\n};\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nimport { Link, updateHistoryRecord } from \"../helpers.js\";\nimport { query, queryAll, nextTick, compareArrays } from \"../utils.js\";\nconst renderPage = function(page, { popstate, fragment } = {}) {\n  document.documentElement.classList.remove(\"is-leaving\");\n  const isCurrentPage = this.getCurrentUrl() === page.url;\n  if (!isCurrentPage) {\n    console.log(\"not current page:\", this.getCurrentUrl(), \"vs\", page.url, page);\n    return;\n  }\n  const skipTransition = fragment || popstate && !this.options.animateHistoryBrowsing;\n  const url = new Link(page.responseURL).getAddress();\n  if (window.location.pathname !== url) {\n    updateHistoryRecord(url);\n    this.cache.cacheUrl(__spreadProps(__spreadValues({}, page), { url }));\n  }\n  if (!skipTransition) {\n    document.documentElement.classList.add(\"is-rendering\");\n  }\n  const replaceBlocks = () => {\n    this.triggerEvent(\"willReplaceContent\", popstate);\n    page.blocks.forEach((html, i) => {\n      const block = query(`[data-swup=\"${i}\"]`, document.body);\n      block.outerHTML = html;\n    });\n    this.triggerEvent(\"contentReplaced\", popstate);\n  };\n  const replaceFragments = () => {\n    const fragments = Object.entries(page.fragments);\n    if (!fragments.length) {\n      console.warn(\"[swup] No fragments found, replacing whole page\");\n      return false;\n    }\n    const { fragmentContainerAttr } = this.options;\n    const fragmentsOnPage = queryAll(`[${fragmentContainerAttr}]`).filter((el) => fragment === true || fragment === el.getAttribute(fragmentContainerAttr));\n    const fragmentsToReplace = fragments.filter(([name]) => fragment === true || fragment === name);\n    const hasIdenticalFragmentContainers = compareArrays(\n      fragmentsOnPage.map((el) => el.getAttribute(fragmentContainerAttr)),\n      fragmentsToReplace.map(([name]) => name)\n    );\n    if (!hasIdenticalFragmentContainers) {\n      console.warn(\"[swup] Mismatching fragments on current and new page, replacing whole page\");\n      return false;\n    }\n    if (typeof fragment === \"string\" && !page.fragments[fragment]) {\n      console.warn(`[swup] Fragment \"${fragment}\" not found, replacing whole page`);\n      return false;\n    }\n    document.documentElement.classList.add(\"is-fragment\");\n    this.triggerEvent(\"willReplaceContent\", popstate);\n    this.triggerEvent(\"willReplaceFragments\", popstate);\n    fragmentsToReplace.forEach(([name, html]) => {\n      const container = query(`[${fragmentContainerAttr}=\"${name}\"]`);\n      if (container) {\n        container.outerHTML = html;\n      }\n    });\n    this.triggerEvent(\"contentReplaced\", popstate);\n    this.triggerEvent(\"fragmentsReplaced\", popstate);\n  };\n  if (fragment) {\n    if (replaceFragments() === false) {\n      console.log(\"Fragments failed, replacing blocks\");\n      nextTick(() => {\n        this.loadPage({ url }, popstate);\n      });\n      return;\n    }\n  } else {\n    replaceBlocks();\n  }\n  document.title = page.title;\n  this.triggerEvent(\"pageView\", popstate);\n  if (!this.options.cache) {\n    this.cache.empty();\n  }\n  this.enterPage({ popstate, skipTransition });\n  this.scrollToElement = null;\n};\nexport default renderPage;\n","const triggerEvent = function(eventName, originalEvent) {\n  this._handlers[eventName].forEach((handler) => {\n    try {\n      handler(originalEvent);\n    } catch (error) {\n      console.error(error);\n    }\n  });\n  const event = new CustomEvent(\"swup:\" + eventName, { detail: eventName });\n  document.dispatchEvent(event);\n};\nexport default triggerEvent;\n","const updateTransition = function(from, to, custom) {\n  this.transition = { from, to, custom };\n};\nexport default updateTransition;\n","export * from \"./utils/index.js\";\n","export const query = (selector, context = document) => {\n  if (typeof selector !== \"string\") {\n    return selector;\n  }\n  return context.querySelector(selector);\n};\nexport const queryAll = (selector, context = document) => {\n  if (typeof selector !== \"string\") {\n    return selector;\n  }\n  return Array.from(context.querySelectorAll(selector));\n};\nexport const nextTick = (callback) => {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      callback();\n    });\n  });\n};\nexport const escapeCssIdentifier = (ident) => {\n  if (window.CSS && window.CSS.escape) {\n    return CSS.escape(ident);\n  } else {\n    return ident;\n  }\n};\nexport const compareArrays = (array1, array2) => {\n  return array1.length === array2.length && array1.every((value, index) => value === array2[index]);\n};\nexport const toMs = (s) => {\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\n\t        // webpack-livereload-plugin\n\t        (function() {\n\t          if (typeof window === \"undefined\") { return };\n\t          var id = \"webpack-livereload-plugin-script-c0da962ac29b3ff4\";\n\t          if (document.getElementById(id)) { return; }\n\t          var el = document.createElement(\"script\");\n\t          el.id = id;\n\t          el.async = true;\n\t          el.src = \"//\" + location.hostname + \":35729/livereload.js\";\n\t          document.getElementsByTagName(\"head\")[0].appendChild(el);\n\t          console.log(\"[Live Reload] enabled\");\n\t        }());\n\t        // Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import \"../scss/app.scss\";\nimport Swup from \"../../../swup/src/index.js\";\nconst options = {\n  containers: [\"#swup\", \"#nav\"],\n  cache: true,\n  linkSelector: `a[href^=\"${window.location.origin}\"]:not([data-no-swup]), a[href^=\"./\"]:not([data-no-swup]), a[href^=\"#\"]:not([data-no-swup])`,\n  plugins: []\n};\nconst swup = new Swup(options);\nwindow.swup = swup;\nlet modalCloseUrl = null;\nconst setModalCloseUrl = (e) => {\n  const wasFilterSet = Boolean(new URL(window.location.href).searchParams.get(\"filter\"));\n  if (wasFilterSet)\n    modalCloseUrl = window.location.href;\n};\nswup.on(\"transitionStart\", setModalCloseUrl);\nconst applyModalCloseUrl = (e) => {\n  if (modalCloseUrl == null)\n    return;\n  document.querySelectorAll(\"[data-apply-modal-close-url]\").forEach((el) => el.href = modalCloseUrl);\n};\nswup.on(\"contentReplaced\", applyModalCloseUrl);\nconst closeModalOnEscape = (e) => {\n  if (e.key !== \"Escape\")\n    return;\n  const closeLink = document.querySelector(\"a.character_close\");\n  if (!closeLink)\n    return;\n  closeLink.click();\n};\nwindow.addEventListener(\"keydown\", closeModalOnEscape);\n"],"names":[],"sourceRoot":""}